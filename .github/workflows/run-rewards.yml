name: "Run Microsoft Rewards Script (daily random 07-10 ET with jitter)"

on:
  schedule:
    - cron: '0 11 * * *'
    - cron: '0 12 * * *'
    - cron: '0 13 * * *'
    - cron: '0 14 * * *'
    - cron: '0 15 * * *'
  workflow_dispatch:
    inputs:
      simulate_schedule:
        description: 'Set to true to simulate schedule behavior (enable jitter) for manual runs'
        required: false
        default: 'false'

jobs:
  run-rewards:
    runs-on: ubuntu-latest
    timeout-minutes: 360
    env:
      NODE_VERSION: '18'
      SIMULATE_SCHEDULE: ${{ github.event.inputs.simulate_schedule || 'false' }}

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: "Decide whether this scheduled run should execute (slot selection in America/Toronto)"
        shell: bash
        run: |
          set -euo pipefail
          LOCAL_DATE=$(TZ='America/Toronto' date +%F)
          LOCAL_HOUR=$(TZ='America/Toronto' date +%H)
          echo "Toronto local date: $LOCAL_DATE  hour: $LOCAL_HOUR"
          HASH=$(printf '%s' "$LOCAL_DATE" | sha256sum | awk '{print $1}')
          LAST_HEX=${HASH: -1}
          SLOT=$((16#$LAST_HEX % 4))
          echo "Slot for today (0..3): $SLOT"
          case "$LOCAL_HOUR" in
            07) EXPECTED=0 ;;
            08) EXPECTED=1 ;;
            09) EXPECTED=2 ;;
            10) EXPECTED=3 ;;
            *) echo "Local hour $LOCAL_HOUR not in 07-10 ET; exiting quickly."; exit 0 ;;
          esac
          echo "Expected slot for this hour: $EXPECTED"
          if [ "$SLOT" -ne "$EXPECTED" ]; then
            echo "Not this hour's chosen run — exiting quickly to save runner time."
            exit 0
          fi
          echo "This job won the day's slot (Toronto time) — continuing."

      - name: "Compute jitter and sleep (winning job) — skip for manual runs unless simulate_schedule=true"
        shell: bash
        env:
          SIMULATE_SCHEDULE: ${{ env.SIMULATE_SCHEDULE }}
        run: |
          set -euo pipefail
          EVENT_NAME="${GITHUB_EVENT_NAME:-}"
          echo "Event name: $EVENT_NAME  simulate_schedule: ${SIMULATE_SCHEDULE:-}"
          if [ "$EVENT_NAME" = "workflow_dispatch" ] && [ "${SIMULATE_SCHEDULE:-}" != "true" ]; then
            echo "Manual run detected and simulate_schedule != true — skipping jitter sleep."
          else
            LOCAL_DATE=$(TZ='America/Toronto' date +%F)
            LOCAL_HOUR=$(TZ='America/Toronto' date +%H)
            HASH2=$(printf '%s' "${LOCAL_DATE}${LOCAL_HOUR}" | sha256sum | awk '{print $1}')
            LAST2=${HASH2: -2}
            DEC=$((16#$LAST2))
            JITTER_MIN=$((DEC % 60))
            echo "Sleeping for ${JITTER_MIN} minute(s) (Toronto local jitter)"
            sleep $((JITTER_MIN * 60))
          fi

      - name: "Write src/accounts.json from secret (handles string-wrapped JSON and base64)"
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p src

          # Preferred: single-line base64 secret
          if [ -n "${{ secrets.ACCOUNTS_JSON_B64 }}" ]; then
            printf '%s' "${{ secrets.ACCOUNTS_JSON_B64 }}" | base64 --decode > src/accounts.json \
              || { echo "ERROR: failed to decode ACCOUNTS_JSON_B64"; exit 1; }

          elif [ -n "${{ secrets.ACCOUNTS_JSON }}" ]; then
            echo "ACCOUNTS_JSON present — attempting robust handling."
            RAW="${{ secrets.ACCOUNTS_JSON }}"

            # Strip a single pair of surrounding quotes if present (unescape literal-string case)
            case "$RAW" in
              \"*\" ) RAW="${RAW#\"}"; RAW="${RAW%\"}" ;;
              \'*\' ) RAW="${RAW#\'}"; RAW="${RAW%\'}" ;;
            esac

            # If it already looks like JSON (starts with { or [), accept it
            case "$RAW" in
              [\{[]* )
                printf '%s' "$RAW" > src/accounts.json
                ;;
              * )
                # Try treating RAW as base64 -> decode to temp and validate
                TMP_DEC="$(mktemp)"
                if printf '%s' "$RAW" | grep -Eq '^[A-Za-z0-9+/=]+$' && printf '%s' "$RAW" | base64 --decode > "$TMP_DEC" 2>/dev/null; then
                  # Validate decoded content
                  if command -v jq >/dev/null 2>&1; then
                    if jq . "$TMP_DEC" >/dev/null 2>&1; then
                      mv "$TMP_DEC" src/accounts.json
                    else
                      rm -f "$TMP_DEC"
                      echo "ERROR: ACCOUNTS_JSON appears base64 but decoded content is not valid JSON."
                      exit 1
                    fi
                  else
                    # fallback to node for validation
                    if node -e "try{JSON.parse(require('fs').readFileSync('$TMP_DEC','utf8')); process.exit(0)}catch(e){ process.exit(2) }"; then
                      mv "$TMP_DEC" src/accounts.json
                    else
                      rm -f "$TMP_DEC"
                      echo "ERROR: ACCOUNTS_JSON appears base64 but decoded content is not valid JSON (node fallback)."
                      exit 1
                    fi
                  fi
                else
                  rm -f "$TMP_DEC" 2>/dev/null || true
                  echo "ERROR: ACCOUNTS_JSON does not look like raw JSON and is not valid base64 → cannot interpret."
                  exit 1
                fi
                ;;
            esac

          else
            echo "ERROR: No ACCOUNTS_JSON_B64 or ACCOUNTS_JSON secret found. Set one of them."
            exit 1
          fi

          # Report only safe metadata (no content preview)
          echo "Wrote src/accounts.json (size: $(wc -c < src.accounts.json) bytes)."

          # Validate JSON without printing content
          if command -v jq >/dev/null 2>&1; then
            jq . src.accounts.json >/dev/null 2>&1 || { echo "ERROR: src.accounts.json invalid JSON according to jq"; exit 1; }
            echo "accounts.json validated by jq."
          else
            node -e "try{JSON.parse(require('fs').readFileSync('src/accounts.json','utf8')); console.log('accounts.json validated by node')}catch(e){ console.error('Invalid JSON:', e.message); process.exit(2) }"
          fi

      - name: "Install Node dependencies (npm i)"
        shell: bash
        run: |
          set -euo pipefail
          # Install packages using npm i (as requested)
          npm i
          echo "node: $(node -v); npm: $(npm -v)"

      - name: "Build the project (npm run build)"
        shell: bash
        run: |
          set -euo pipefail
          npm run build

      - name: "Run the built script and save logs"
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p logs
          # Run the script and capture output to logs/script.log (do not print secrets)
          npm run start 2>&1 | tee logs/script.log || true
          echo "Captured logs to logs/script.log"

      - name: "Sanitize logs/script.log (redact emails/passwords/tokens/base64-like strings)"
        shell: bash
        run: |
          set -euo pipefail
          # operate on a copy to be safe
          cp logs/script.log logs/script.log.raw || true

          # 1) redact JSON password fields like "password": "value"
          sed -E -i 's/("password"[[:space:]]*:[[:space:]]*)"[^"]*"/\1"***REDACTED***"/Ig' logs/script.log

          # 2) redact common password patterns like password: value or password= value
          sed -E -i 's/([Pp]ass(word)?[[:space:]]*[:=][[:space:]]*)[^[:space:],;]+/\1***REDACTED***/g' logs/script.log

          # 3) redact email addresses
          sed -E -i 's/[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}/***REDACTED_EMAIL***/g' logs/script.log

          # 4) redact Authorization headers / bearer/basic tokens
          sed -E -i 's/([Aa]uthorization[[:space:]]*[:=][[:space:]]*(Bearer|Basic)?[[:space:]]*)[^[:space:]]+/\1***REDACTED***/g' logs/script.log

          # 5) redact long base64-like strings (heuristic for API keys / tokens)
          sed -E -i 's/[A-Za-z0-9+/]{40,}={0,2}/***REDACTED_BASE64***/g' logs/script.log

          # 6) fallback: remove any occurrences of the literal word "see" following "password" patterns (your placeholder)
          sed -E -i 's/("password"[[:space:]]*:[[:space:]]*)"see"/\1"***REDACTED***"/Ig' logs/script.log

          # Keep the raw backup out of artifacts by removing it
          rm -f logs/script.log.raw || true

      - name: "Upload sanitized logs artifact"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: microsoft-rewards-logs-${{ github.run_id }}
          path: logs/script.log
