name: "Run Microsoft Rewards Script (daily random 07-10 ET with jitter)"

on:
  schedule:
    - cron: '0 11 * * *'
    - cron: '0 12 * * *'
    - cron: '0 13 * * *'
    - cron: '0 14 * * *'
    - cron: '0 15 * * *'
  workflow_dispatch:
    inputs:
      simulate_schedule:
        description: 'Set to true to simulate schedule behavior (enable jitter) for manual runs'
        required: false
        default: 'false'

jobs:
  run-rewards:
    runs-on: ubuntu-latest
    timeout-minutes: 360
    env:
      NODE_VERSION: '18'
      SIMULATE_SCHEDULE: ${{ github.event.inputs.simulate_schedule || 'false' }}

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Decide whether this scheduled run should execute (slot selection in America/Toronto)
        shell: bash
        run: |
          set -euo pipefail
          LOCAL_DATE=$(TZ='America/Toronto' date +%F)
          LOCAL_HOUR=$(TZ='America/Toronto' date +%H)
          echo "Toronto local date: $LOCAL_DATE  hour: $LOCAL_HOUR"
          HASH=$(printf '%s' "$LOCAL_DATE" | sha256sum | awk '{print $1}')
          LAST_HEX=${HASH: -1}
          SLOT=$((16#$LAST_HEX % 4))
          echo "Slot for today (0..3): $SLOT"
          case "$LOCAL_HOUR" in
            07) EXPECTED=0 ;;
            08) EXPECTED=1 ;;
            09) EXPECTED=2 ;;
            10) EXPECTED=3 ;;
            *) echo "Local hour $LOCAL_HOUR not in 07-10 ET; exiting quickly."; exit 0 ;;
          esac
          echo "Expected slot for this hour: $EXPECTED"
          if [ "$SLOT" -ne "$EXPECTED" ]; then
            echo "Not this hour's chosen run — exiting quickly to save runner time."
            exit 0
          fi
          echo "This job won the day's slot (Toronto time) — continuing."

      - name: Compute jitter and sleep (winning job) — skip for manual runs unless simulate_schedule=true
        shell: bash
        env:
          SIMULATE_SCHEDULE: ${{ env.SIMULATE_SCHEDULE }}
        run: |
          set -euo pipefail
          EVENT_NAME="${GITHUB_EVENT_NAME:-}"
          echo "Event name: $EVENT_NAME  simulate_schedule: ${SIMULATE_SCHEDULE:-}"
          if [ "$EVENT_NAME" = "workflow_dispatch" ] && [ "${SIMULATE_SCHEDULE:-}" != "true" ]; then
            echo "Manual run detected and simulate_schedule != true — skipping jitter sleep."
          else
            LOCAL_DATE=$(TZ='America/Toronto' date +%F)
            LOCAL_HOUR=$(TZ='America/Toronto' date +%H)
            HASH2=$(printf '%s' "${LOCAL_DATE}${LOCAL_HOUR}" | sha256sum | awk '{print $1}')
            LAST2=${HASH2: -2}
            DEC=$((16#$LAST2))
            JITTER_MIN=$((DEC % 60))
            echo "Sleeping for ${JITTER_MIN} minute(s) (Toronto local jitter)"
            sleep $((JITTER_MIN * 60))
          fi

      - name: "Write src/accounts.json from secret (handles string-wrapped JSON and base64)"
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p src

          # Preferred: single-line base64 secret
          if [ -n "${{ secrets.ACCOUNTS_JSON_B64 }}" ]; then
            printf '%s' "${{ secrets.ACCOUNTS_JSON_B64 }}" | base64 --decode > src/accounts.json \
              || { echo "ERROR: failed to decode ACCOUNTS_JSON_B64"; exit 1; }

          elif [ -n "${{ secrets.ACCOUNTS_JSON }}" ]; then
            echo "ACCOUNTS_JSON present — attempting robust handling."
            # Export the secret into an env var for Node (secret masking remains in logs)
            export ACC_RAW="${{ secrets.ACCOUNTS_JSON }}"

            node - <<'NODE'
const fs = require('fs');
const raw = process.env.ACC_RAW || '';
const trimmed = raw.trim();

function looksLikeJson(s){ return /^[\[{]/.test(s.trim()); }

let result = null;

// 1) If it already looks like JSON (starts with { or [), accept it.
if (looksLikeJson(trimmed)) {
  result = raw;
} else {
  // 2) Try to parse as a JSON string literal (e.g. "\"[ {...} ]\"")
  try {
    const parsed = JSON.parse(raw);
    if (typeof parsed === 'string') {
      // parsed is the inner JSON text
      result = parsed;
    } else {
      // parsed is already an object/array -> pretty-print to JSON text
      result = JSON.stringify(parsed, null, 2);
    }
  } catch (e1) {
    // 3) If there are outer quotes that weren't escaped, try to strip a single pair
    if ((raw.startsWith('"') && raw.endsWith('"')) || (raw.startsWith("'") && raw.endsWith("'"))) {
      const stripped = raw.slice(1, -1);
      if (looksLikeJson(stripped)) {
        result = stripped;
      } else {
        // 4) Try base64 decode of the original raw
        try {
          const dec = Buffer.from(raw, 'base64').toString('utf8');
          if (looksLikeJson(dec)) result = dec;
          else throw new Error('base64 decoded content not JSON');
        } catch (e3) {
          console.error('Could not interpret ACCOUNTS_JSON secret as JSON, JSON-string, or base64.');
          process.exit(2);
        }
      }
    } else {
      // 5) Try decoding as base64 directly
      try {
        const dec = Buffer.from(raw, 'base64').toString('utf8');
        if (looksLikeJson(dec)) result = dec;
        else {
          console.error('Secret did not parse and base64-decoded content is not JSON.');
          process.exit(2);
        }
      } catch (e2) {
        console.error('Secret did not parse as JSON and was not valid base64.');
        process.exit(2);
      }
    }
  }
}

// Final sanity check
if (!result || !looksLikeJson(result)) {
  console.error('Final interpreted content does not appear to be JSON.');
  process.exit(2);
}

// Write file
fs.writeFileSync('src/accounts.json', result, 'utf8');
console.log('Wrote src/accounts.json (size:', fs.statSync('src/accounts.json').size, 'bytes)');
NODE

          else
            echo "ERROR: No ACCOUNTS_JSON_B64 or ACCOUNTS_JSON secret found. Set one of them."
            exit 1
          fi

          # Small safe preview and validation (won't expose secrets)
          echo "Preview (first 120 bytes):"
          head -c 120 src/accounts.json || true
          echo
          if command -v jq >/dev/null 2>&1; then
            jq . src/accounts.json >/dev/null 2>&1 || { echo "ERROR: src/accounts.json invalid JSON according to jq"; exit 1; }
            echo "accounts.json validated by jq."
          else
            node -e "try{JSON.parse(require('fs').readFileSync('src/accounts.json','utf8')); console.log('accounts.json validated by node') }catch(e){ console.error('Invalid JSON:', e.message); process.exit(2) }"
          fi

      - name: Write src/config.json from base64 secret and validate (optional)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p src
          if [ -n "${{ secrets.CONFIG_JSON_B64 }}" ]; then
            echo "Decoding CONFIG_JSON_B64 -> src/config.json"
            printf '%s' "${{ secrets.CONFIG_JSON_B64 }}" | base64 --decode > src/config.json
            echo "Wrote src/config.json (size: $(wc -c < src/config.json) bytes). Preview first 6 lines:"
            sed -n '1,6p' src/config.json || true
            if command -v jq >/dev/null 2>&1; then
              jq . src/config.json >/dev/null 2>&1 || (echo "Invalid JSON in CONFIG_JSON_B64"; sed -n '1,200p' src/config.json || true; exit 1)
            else
              node -e "try{JSON.parse(require('fs').readFileSync('src/config.json','utf8')); console.log('config json ok')}catch(e){console.error('Invalid JSON:', e.message); process.exit(2)}"
            fi
          elif [ -n "${{ secrets.CONFIG_JSON }}" ]; then
            echo "Using raw CONFIG_JSON fallback (fragile)"
            RAW="${{ secrets.CONFIG_JSON }}"
            RAW="${RAW#\"}"; RAW="${RAW%\"}"
            RAW="${RAW#\'}"; RAW="${RAW%\'}"
            printf '%s' "$RAW" > src/config.json
            echo "Wrote src/config.json (size: $(wc -c < src/config.json) bytes)."
          else
            echo "No CONFIG_JSON provided; using repo config.json if present."
          fi

      - name: Install OS packages required by browsers (Playwright) (robust)
        shell: bash
        run: |
          set -euo pipefail
          echo "Updating apt..."
          sudo apt-get update -y
          BASE_PKGS="libnss3 libatk1.0-0 libatk-bridge2.0-0 libcups2 libxss1 libxcomposite1 libxdamage1 libxrandr2 libgtk-3-0 libgbm1 ca-certificates fonts-liberation libappindicator3-1 libatspi2.0-0 lsb-release jq"
          echo "Installing system packages (with libasound2 fallback logic)..."
          if sudo apt-get install -y $BASE_PKGS libasound2; then
            echo "Installed with libasound2"
          elif sudo apt-get install -y $BASE_PKGS libasound2t64; then
            echo "Installed with libasound2t64"
          elif sudo apt-get install -y $BASE_PKGS liboss4-salsa-asound2; then
            echo "Installed with liboss4-salsa-asound2"
          else
            echo "Failed to install any libasound provider; printing apt-cache policy for debugging"
            apt-cache policy libasound2 libasound2t64 liboss4-salsa-asound2 || true
            exit 1
          fi

      - name: Install Node dependencies (clean)
        shell: bash
        run: |
          set -euo pipefail
          npm ci
          echo "node: $(node -v); npm: $(npm -v)"
          npm ls --depth=0 || true

      - name: Verify TypeScript / install if missing
        shell: bash
        run: |
          set -euo pipefail
          if ! npx --no-install tsc --version >/dev/null 2>&1; then
            echo "TypeScript missing; installing locally..."
            npm i -D typescript@latest
          else
            echo "TypeScript present."
            npx tsc --version || true
          fi

      - name: Create tsconfig.ci.json (exclude src/accounts.json) for CI
        shell: bash
        run: |
          set -euo pipefail
          if [ -f tsconfig.json ] && command -v jq >/dev/null 2>&1; then
            jq '(.exclude //= []) | .exclude |= (.+["src/accounts.json"] | unique)' tsconfig.json > tsconfig.ci.json
            echo "Wrote tsconfig.ci.json (tsconfig.json copy with src/accounts.json excluded)."
            head -c 320 tsconfig.ci.json || true
          elif [ ! -f tsconfig.json ]; then
            echo "No tsconfig.json found; skipping tsconfig.ci.json creation."
          else
            echo "jq missing; cannot create tsconfig.ci.json. Continuing without it."
          fi

      - name: "Optional: Run tsc --noEmit as a quick pre-check (using tsconfig.ci.json if present)"
        shell: bash
        run: |
          set -euo pipefail
          if npx --no-install tsc --version >/dev/null 2>&1; then
            if [ -f tsconfig.ci.json ]; then
              echo "Running tsc --noEmit -p tsconfig.ci.json ..."
              npx tsc --noEmit -p tsconfig.ci.json || { echo "tsc (ci) failed; see output"; exit 1; }
            else
              echo "Running tsc --noEmit ..."
              npx tsc --noEmit || { echo "tsc failed; see output"; exit 1; }
            fi
          else
            echo "TypeScript not installed; installing temporarily..."
            npm i -D typescript@latest
            if [ -f tsconfig.ci.json ]; then
              npx tsc --noEmit -p tsconfig.ci.json || { echo "tsc (ci) failed; see output"; exit 1; }
            else
              npx tsc --noEmit || { echo "tsc failed; see output"; exit 1; }
            fi
          fi

      - name: Install Playwright OS deps helper (optional) and browsers
        shell: bash
        run: |
          set -euo pipefail
          if command -v npx >/dev/null 2>&1; then
            echo "Running npx playwright install-deps (may require sudo)..."
            npx playwright install-deps || true
          fi
          echo "Installing Playwright Chromium (with deps)..."
          npx playwright install --with-deps chromium

      - name: Build the project (per README) (use tsconfig.ci.json if present)
        shell: bash
        run: |
          set -euo pipefail
          if [ -f tsconfig.ci.json ]; then
            echo "Compiling with tsconfig.ci.json..."
            npx tsc -p tsconfig.ci.json
          else
            echo "No tsconfig.ci.json — running npm run build (default behaviour)..."
            npm run build
          fi

      - name: Run the built script and save logs
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p logs
          # run script and capture output; don't fail the job on script exit (the log will be available)
          npm run start 2>&1 | tee logs/script.log || true
          echo "Captured logs to logs/script.log"

      - name: Upload logs artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: microsoft-rewards-logs-${{ github.run_id }}
          path: logs/script.log
