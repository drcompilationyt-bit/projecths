name: "Run Microsoft Rewards Script (randomized start around 08:00 Toronto, up to 1.5h jitter)"

on:
  schedule:
    # 12 and 13 UTC cover 08:00 America/Toronto across DST / standard time.
    - cron: '0 12 * * *'
    - cron: '0 13 * * *'
  workflow_dispatch:
    inputs:
      simulate_schedule:
        description: 'Set to true to simulate schedule behaviour (enable jitter) for manual runs'
        required: false
        default: 'false'

jobs:
  run-rewards:
    runs-on: ubuntu-latest
    timeout-minutes: 360
    env:
      NODE_VERSION: '18'
      SIMULATE_SCHEDULE: ${{ github.event.inputs.simulate_schedule || 'false' }}

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: "Decide whether this scheduled run should continue (only the run that hits 08:00 Toronto proceeds)"
        shell: bash
        run: |
          set -euo pipefail
          EVENT_NAME="${GITHUB_EVENT_NAME:-}"
          echo "Event: $EVENT_NAME  simulate_schedule: ${SIMULATE_SCHEDULE:-}"

          # Manual runs without simulate_schedule => run immediately (for testing)
          if [ "$EVENT_NAME" = "workflow_dispatch" ] && [ "${SIMULATE_SCHEDULE:-}" != "true" ]; then
            echo "Manual run requested and simulate_schedule != true — proceeding immediately."
            exit 0
          fi

          # For scheduled runs (or simulated manual), check Toronto local hour
          LOCAL_HOUR_RAW=$(TZ='America/Toronto' date +%H)
          LOCAL_HOUR=${LOCAL_HOUR_RAW#0}
          echo "Toronto local hour: $LOCAL_HOUR (raw: $LOCAL_HOUR_RAW)"

          if [ "$LOCAL_HOUR" -ne 8 ]; then
            echo "Local hour is not 8 — exiting quickly to save runner time."
            exit 0
          fi

          echo "Local hour is 8 — this run will continue and will apply a random jitter (<= 90 minutes)."

      - name: "Compute random jitter (0..90 minutes) and sleep — skipped for manual runs unless simulate_schedule=true"
        shell: bash
        run: |
          set -euo pipefail
          EVENT_NAME="${GITHUB_EVENT_NAME:-}"
          if [ "$EVENT_NAME" = "workflow_dispatch" ] && [ "${SIMULATE_SCHEDULE:-}" != "true" ]; then
            echo "Manual immediate run — skipping jitter sleep."
            exit 0
          fi

          # max jitter seconds = 90 minutes = 5400 sec
          MAX_SEC=$((90 * 60))

          # Secure-ish random 32-bit number reduced modulo MAX_SEC+1 for [0..MAX_SEC]
          RAND_RAW=$(od -An -N4 -tu4 /dev/urandom | tr -d ' ')
          JITTER_SEC=$(( RAND_RAW % (MAX_SEC + 1) ))

          # Log only the delay in seconds (no secrets)
          echo "Sleeping for ${JITTER_SEC} second(s) (random jitter up to 90 minutes)."
          sleep "${JITTER_SEC}"

      - name: "Write src/accounts.json from secret (handles string-wrapped JSON and base64)"
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p src

          if [ -n "${{ secrets.ACCOUNTS_JSON_B64 }}" ]; then
            printf '%s' "${{ secrets.ACCOUNTS_JSON_B64 }}" | base64 --decode > src/accounts.json \
              || { echo "ERROR: failed to decode ACCOUNTS_JSON_B64"; exit 1; }

          elif [ -n "${{ secrets.ACCOUNTS_JSON }}" ]; then
            echo "ACCOUNTS_JSON present — attempting robust handling."
            RAW="${{ secrets.ACCOUNTS_JSON }}"

            # Strip a single pair of surrounding quotes if present
            case "$RAW" in
              \"*\" ) RAW="${RAW#\"}"; RAW="${RAW%\"}" ;;
              \'*\' ) RAW="${RAW#\'}"; RAW="${RAW%\'}" ;;
            esac

            # If it already looks like JSON (starts with { or [), accept it
            case "$RAW" in
              [\{[]* )
                printf '%s' "$RAW" > src/accounts.json
                ;;
              * )
                TMP_DEC="$(mktemp)"
                if printf '%s' "$RAW" | grep -Eq '^[A-Za-z0-9+/=]+$' && printf '%s' "$RAW" | base64 --decode > "$TMP_DEC" 2>/dev/null; then
                  if command -v jq >/dev/null 2>&1; then
                    if jq . "$TMP_DEC" >/dev/null 2>&1; then
                      mv "$TMP_DEC" src/accounts.json
                    else
                      rm -f "$TMP_DEC"
                      echo "ERROR: ACCOUNTS_JSON appears base64 but decoded content is not valid JSON."
                      exit 1
                    fi
                  else
                    if node -e "try{JSON.parse(require('fs').readFileSync('$TMP_DEC','utf8')); process.exit(0)}catch(e){ process.exit(2) }"; then
                      mv "$TMP_DEC" src.accounts.json
                    else
                      rm -f "$TMP_DEC"
                      echo "ERROR: ACCOUNTS_JSON appears base64 but decoded content is not valid JSON (node fallback)."
                      exit 1
                    fi
                  fi
                else
                  rm -f "$TMP_DEC" 2>/dev/null || true
                  echo "ERROR: ACCOUNTS_JSON does not look like raw JSON and is not valid base64 → cannot interpret."
                  exit 1
                fi
                ;;
            esac
          else
            echo "ERROR: No ACCOUNTS_JSON_B64 or ACCOUNTS_JSON secret found. Set one of them."
            exit 1
          fi

          # Safe metadata only
          echo "Wrote src/accounts.json (size: $(wc -c < src/accounts.json) bytes)."

          # Validate JSON without printing content
          if command -v jq >/dev/null 2>&1; then
            jq . src.accounts.json >/dev/null 2>&1 || { echo "ERROR: src/accounts.json invalid JSON according to jq"; exit 1; }
            echo "accounts.json validated by jq."
          else
            node -e "try{JSON.parse(require('fs').readFileSync('src/accounts.json','utf8')); console.log('accounts.json validated by node')}catch(e){ console.error('Invalid JSON:', e.message); process.exit(2) }"
          fi

      - name: "Install Node dependencies (npm i)"
        shell: bash
        run: |
          set -euo pipefail
          npm i --no-audit --no-fund
          echo "node: $(node -v); npm: $(npm -v)"

      - name: "Build the project (npm run build)"
        shell: bash
        run: |
          set -euo pipefail
          npm run build

      - name: "Run the built script and save logs"
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p logs
          # run script and capture output to logs/script.log (do not print secrets)
          npm run start 2>&1 | tee logs/script.log || true
          echo "Captured logs to logs/script.log"

      - name: "Sanitize logs/script.log (redact emails/passwords/tokens/base64-like strings)"
        shell: bash
        run: |
          set -euo pipefail
          cp logs/script.log logs/script.log.raw || true

          # 1) redact JSON password fields like "password": "value"
          sed -E -i 's/("password"[[:space:]]*:[[:space:]]*)"[^"]*"/\1"***REDACTED***"/Ig' logs/script.log

          # 2) redact common password patterns like password: value or password= value
          sed -E -i 's/([Pp]ass(word)?[[:space:]]*[:=][[:space:]]*)[^[:space:],;]+/\1***REDACTED***/g' logs/script.log

          # 3) redact email addresses
          sed -E -i 's/[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}/***REDACTED_EMAIL***/g' logs/script.log

          # 4) redact Authorization headers / bearer/basic tokens
          sed -E -i 's/([Aa]uthorization[[:space:]]*[:=][[:space:]]*(Bearer|Basic)?[[:space:]]*)[^[:space:]]+/\1***REDACTED***/g' logs/script.log

          # 5) redact long base64-like strings (heuristic for API keys / tokens)
          sed -E -i 's/[A-Za-z0-9+/]{40,}={0,2}/***REDACTED_BASE64***/g' logs/script.log

          # 6) fallback: remove any occurrences of the literal word "see" following "password" patterns (your placeholder)
          sed -E -i 's/("password"[[:space:]]*:[[:space:]]*)"see"/\1"***REDACTED***"/Ig' logs.script.log

          rm -f logs/script.log.raw || true

      - name: "Upload sanitized logs artifact"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: microsoft-rewards-logs-${{ github.run_id }}
          path: logs/script.log
